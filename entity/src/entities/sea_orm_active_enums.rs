//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.15

use sea_orm::sea_query;
use sea_orm::{
    entity::prelude::*,
    sea_query::{ArrayType, ValueType, ValueTypeErr},
    sqlx, TryGetError, TryGetable,
};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, EnumIter, ToSchema)]
pub enum Operatorenum {
    Above,
    Below,
    Equal,
    NotEqual,
    NoLessThan,
    NoMoreThan,
}

#[derive(Iden)]
enum OperatorenumIden {
    Operatorenum,
}

#[derive(Iden)]
enum OperatorenumVariants {
    Above,
    Below,
    Equal,
    NotEqual,
    NoLessThan,
    NoMoreThan,
}

// Реализация From для Operatorenum
impl From<Operatorenum> for String {
    fn from(op: Operatorenum) -> Self {
        match op {
            Operatorenum::Above => "ABOVE".to_string(),
            Operatorenum::Below => "BELOW".to_string(),
            Operatorenum::Equal => "EQUAL".to_string(),
            Operatorenum::NotEqual => "NOT_EQUAL".to_string(),
            Operatorenum::NoLessThan => "NO_LESS_THAN".to_string(),
            Operatorenum::NoMoreThan => "NO_MORE_THAN".to_string(),
        }
    }
}

impl From<Operatorenum> for Value {
    fn from(op: Operatorenum) -> Self {
        let string_value: String = op.into(); // Convert enum to string
        Value::String(Some(Box::new(string_value))) // Wrap in Value::String
    }
}

// Реализация Into для String
impl Into<Operatorenum> for String {
    fn into(self) -> Operatorenum {
        match self.as_str() {
            "ABOVE" => Operatorenum::Above,
            "BELOW" => Operatorenum::Below,
            "EQUAL" => Operatorenum::Equal,
            "NOT_EQUAL" => Operatorenum::NotEqual,
            "NO_LESS_THAN" => Operatorenum::NoLessThan,
            "NO_MORE_THAN" => Operatorenum::NoMoreThan,
            _ => panic!("Invalid value for Operatorenum"),
        }
    }
}

impl TryInto<Operatorenum> for Value {
    type Error = DbErr;

    fn try_into(self) -> Result<Operatorenum, Self::Error> {
        if let Value::String(Some(string_value)) = self {
            match string_value.as_str() {
                "ABOVE" => Ok(Operatorenum::Above),
                "BELOW" => Ok(Operatorenum::Below),
                "EQUAL" => Ok(Operatorenum::Equal),
                "NOT_EQUAL" => Ok(Operatorenum::NotEqual),
                "NO_LESS_THAN" => Ok(Operatorenum::NoLessThan),
                "NO_MORE_THAN" => Ok(Operatorenum::NoMoreThan),
                _ => Err(DbErr::Custom("Invalid Operatorenum value".to_string())),
            }
        } else {
            Err(DbErr::Custom("Expected a String Value".to_string()))
        }
    }
}

impl TryGetable for Operatorenum {
    fn try_get_by<I: sea_orm::ColIdx>(res: &QueryResult, index: I) -> Result<Self, TryGetError> {
        let value: String = res.try_get_by(index)?;
        match value.as_str() {
            "ABOVE" => Ok(Operatorenum::Above),
            "BELOW" => Ok(Operatorenum::Below),
            "EQUAL" => Ok(Operatorenum::Equal),
            "NOT_EQUAL" => Ok(Operatorenum::NotEqual),
            "NO_LESS_THAN" => Ok(Operatorenum::NoLessThan),
            "NO_MORE_THAN" => Ok(Operatorenum::NoMoreThan),
            enum_type => Err(TryGetError::DbErr(DbErr::Query(RuntimeErr::SqlxError(
                sqlx::error::Error::TypeNotFound {
                    type_name: enum_type.to_string(),
                },
            )))),
        }
    }
}

// Реализация ValueType для Operatorenum
impl ValueType for Operatorenum {
    fn try_from(v: Value) -> Result<Self, ValueTypeErr> {
        match v {
            Value::String(s) => {
                // Преобразуем Box<String> в &str
                let s: &str = s.as_ref().expect("Expected a valid string"); // здесь проверяем на None
                match s {
                    "ABOVE" => Ok(Operatorenum::Above),
                    "BELOW" => Ok(Operatorenum::Below),
                    "EQUAL" => Ok(Operatorenum::Equal),
                    "NOT_EQUAL" => Ok(Operatorenum::NotEqual),
                    "NO_LESS_THAN" => Ok(Operatorenum::NoLessThan),
                    "NO_MORE_THAN" => Ok(Operatorenum::NoMoreThan),
                    _ => Err(ValueTypeErr), // если строка не соответствует ни одному варианту
                }
            }
            _ => Err(ValueTypeErr), // если тип не совпадает
        }
    }

    fn type_name() -> String {
        "operatorenum".to_string()
    }

    fn array_type() -> ArrayType {
        ArrayType::String
    }

    fn column_type() -> ColumnType {
        ColumnType::Enum {
            name: SeaRc::new(OperatorenumIden::Operatorenum),
            variants: vec![
                SeaRc::new(OperatorenumVariants::Above),
                SeaRc::new(OperatorenumVariants::Below),
                SeaRc::new(OperatorenumVariants::Equal),
                SeaRc::new(OperatorenumVariants::NotEqual),
                SeaRc::new(OperatorenumVariants::NoLessThan),
                SeaRc::new(OperatorenumVariants::NoMoreThan),
            ],
        }
    }
}
